local ESP = {}

local Players = game:GetService("Players")
local RunService = getgenv().RunService
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera
local VisualTab = getgenv().VisualTab

-- Настройки ESP
local ESPSettings = {
	Enabled = false,
	Box = false,
	BoxType = "None",
	BoxStyle = "Default",
	Box3DStyle = "Fill",
	BoxColor = Color3.fromRGB(255, 0, 0),
	VisibilityMode = "None", -- None, All, Team, Enemy
	VisibleCheck = false,
	VisibilityStyle = "Smart", -- Изменено на Smart по умолчанию
	VisibilityDefaultColor = Color3.fromRGB(0, 0, 255), -- Синий по умолчанию
	Name = false,
	NameColor = Color3.fromRGB(255, 255, 255),
	Health = false,
	HealthColor = Color3.fromRGB(0, 255, 0),
	Distance = false,
	DistanceColor = Color3.fromRGB(255, 255, 255),
	Skeleton = false,
	SkeletonColor = Color3.fromRGB(255, 255, 255),
	Chams = false,
	ChamsColor = Color3.fromRGB(255, 0, 0),
	MaxDistance = 2000,
	BoxThickness = 1
}

-- Хранилище для ESP-объектов
local ESPObjects = {}

-- Функции для создания объектов Drawing
local function NewQuad(thickness, color)
	local quad = Drawing.new("Quad")
	quad.Visible = false
	quad.PointA = Vector2.new(0, 0)
	quad.PointB = Vector2.new(0, 0)
	quad.PointC = Vector2.new(0, 0)
	quad.PointD = Vector2.new(0, 0)
	quad.Color = color
	quad.Filled = false
	quad.Thickness = thickness
	quad.Transparency = 1
	return quad
end

local function NewLine(thickness, color)
	local line = Drawing.new("Line")
	line.Visible = false
	line.From = Vector2.new(0, 0)
	line.To = Vector2.new(0, 0)
	line.Color = color
	line.Thickness = thickness
	line.Transparency = 1
	return line
end

local function NewText()
	local text = Drawing.new("Text")
	text.Visible = false
	text.Size = 16
	text.Center = true
	text.Outline = true
	text.Color = Color3.fromRGB(255, 255, 255)
	return text
end

local function NewEye()
	local eye = Drawing.new("Circle")
	eye.Visible = false
	eye.Radius = 10
	eye.Thickness = 1
	eye.Color = Color3.fromRGB(255, 0, 0)
	eye.Filled = true
	return eye
end

-- Функция для создания заполненного 3D-бокса (Fill)
local function create3DBoxFill(character)
	local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
	if not humanoidRootPart then return nil end

	local size = Vector3.new(4, 6, 2)
	local head = character:FindFirstChild("Head")
	local torso = character:FindFirstChild("UpperTorso") or character:FindFirstChild("Torso")
	local leftLeg = character:FindFirstChild("LeftLowerLeg") or character:FindFirstChild("Left Leg")
	local rightLeg = character:FindFirstChild("RightLowerLeg") or character:FindFirstChild("Right Leg")
	local leftArm = character:FindFirstChild("LeftLowerArm") or character:FindFirstChild("Left Arm")
	local rightArm = character:FindFirstChild("RightLowerArm") or character:FindFirstChild("Right Arm")

	if head and torso and leftLeg and rightLeg and leftArm and rightArm then
		local height = (head.Position.Y - math.min(leftLeg.Position.Y, rightLeg.Position.Y)) + (head.Size.Y / 2)
		local width = math.abs(leftArm.Position.X - rightArm.Position.X) + math.max(leftArm.Size.X, rightArm.Size.X)
		local depth = math.abs(torso.Position.Z - humanoidRootPart.Position.Z) * 2 + torso.Size.Z
		size = Vector3.new(math.max(width, 4), math.max(height, 6), math.max(depth, 2))
	end

	local box = Instance.new("BoxHandleAdornment")
	box.Size = size
	box.Adornee = humanoidRootPart
	box.Color3 = ESPSettings.BoxColor
	box.Transparency = 0.5
	box.ZIndex = 10
	box.AlwaysOnTop = true
	local container = Instance.new("Folder")
	container.Name = "ESPContainer"
	container.Parent = game:GetService("CoreGui")
	box.Parent = container
	return box, container
end

-- Функция для создания каркасного 3D-бокса (Default)
local function create3DBoxDefault(character)
	local lines = {}
	local size = Vector3.new(4, 6, 2)
	local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
	if humanoidRootPart then
		local head = character:FindFirstChild("Head")
		local torso = character:FindFirstChild("UpperTorso") or character:FindFirstChild("Torso")
		local leftLeg = character:FindFirstChild("LeftLowerLeg") or character:FindFirstChild("Left Leg")
		local rightLeg = character:FindFirstChild("RightLowerLeg") or character:FindFirstChild("Right Leg")
		local leftArm = character:FindFirstChild("LeftLowerArm") or character:FindFirstChild("Left Arm")
		local rightArm = character:FindFirstChild("RightLowerArm") or character:FindFirstChild("Right Arm")

		if head and torso and leftLeg and rightLeg and leftArm and rightArm then
			local height = (head.Position.Y - math.min(leftLeg.Position.Y, rightLeg.Position.Y)) + (head.Size.Y / 2)
			local width = math.abs(leftArm.Position.X - rightArm.Position.X) + math.max(leftArm.Size.X, rightArm.Size.X)
			local depth = math.abs(torso.Position.Z - humanoidRootPart.Position.Z) * 2 + torso.Size.Z
			size = Vector3.new(math.max(width, 4), math.max(height, 6), math.max(depth, 2))
		end
	end

	local edges = {
		{1, 2}, {2, 3}, {3, 4}, {4, 1},
		{5, 6}, {6, 7}, {7, 8}, {8, 5},
		{1, 5}, {2, 6}, {3, 7}, {4, 8}
	}

	for i, edge in ipairs(edges) do
		lines["Edge" .. i] = NewLine(ESPSettings.BoxThickness, ESPSettings.BoxColor)
	end

	return lines, size
end

-- Функция для создания чамсов
local function createChams(character)
	local highlight = Instance.new("Highlight")
	highlight.FillColor = ESPSettings.ChamsColor
	highlight.FillTransparency = 0.5
	highlight.OutlineColor = ESPSettings.ChamsColor
	highlight.OutlineTransparency = 0
	highlight.Adornee = character
	highlight.Parent = character
	return highlight
end

-- Функция для создания скелета
local function createSkeleton(player)
	local lines = {}
	local connections = {
		R6 = {
			{"Head", "Torso"},
			{"Torso", "Left Arm"},
			{"Torso", "Right Arm"},
			{"Torso", "Left Leg"},
			{"Torso", "Right Leg"}
		},
		R15 = {
			{"Head", "UpperTorso"},
			{"UpperTorso", "LowerTorso"},
			{"UpperTorso", "LeftUpperArm"},
			{"LeftUpperArm", "LeftLowerArm"},
			{"LeftLowerArm", "LeftHand"},
			{"UpperTorso", "RightUpperArm"},
			{"RightUpperArm", "RightLowerArm"},
			{"RightLowerArm", "RightHand"},
			{"LowerTorso", "LeftUpperLeg"},
			{"LeftUpperLeg", "LeftLowerLeg"},
			{"LeftLowerLeg", "LeftFoot"},
			{"LowerTorso", "RightUpperLeg"},
			{"RightUpperLeg", "RightLowerLeg"},
			{"RightLowerLeg", "RightFoot"}
		}
	}
	local character = player.Character
	if not character or not character:FindFirstChild("Humanoid") then
		return lines
	end
	local rigType = character.Humanoid.RigType == Enum.HumanoidRigType.R15 and "R15" or "R6"
	for _, pair in ipairs(connections[rigType]) do
		local part1 = character:FindFirstChild(pair[1])
		local part2 = character:FindFirstChild(pair[2])
		if part1 and part2 then
			lines[pair[1] .. "_" .. pair[2]] = NewLine(1, ESPSettings.SkeletonColor)
		else
			warn("Skeleton: Missing parts for " .. player.Name .. " - " .. pair[1] .. " or " .. pair[2])
		end
	end
	return lines
end

-- Очистка объектов игрока
local function clearPlayerObjects(player)
	if ESPObjects[player] then
		for key, obj in pairs(ESPObjects[player]) do
			if key == "BoxCorners" or key == "Skeleton" or key == "Box3DDefault" then
				for _, subObj in pairs(obj) do
					if subObj then
						subObj:Remove()
					end
				end
			elseif key == "Box3DContainer" then
				if obj then
					obj:Destroy()
				end
			elseif typeof(obj) == "Instance" then
				if obj then
					obj:Destroy()
				end
			else
				if obj then
					obj:Remove()
				end
			end
		end
		ESPObjects[player] = nil
	end
end

-- Функция для скрытия всех объектов
local function hideAllObjects(objects)
	if objects.Box then
		objects.Box.Visible = false
	end
	if objects.BoxCorners then
		for _, line in pairs(objects.BoxCorners) do
			if line then
				line.Visible = false
			end
		end
	end
	if objects.Box3D then
		objects.Box3D.Visible = false
	end
	if objects.Box3DDefault then
		for _, line in pairs(objects.Box3DDefault) do
			if line then
				line.Visible = false
			end
		end
	end
	if objects.Name then
		objects.Name.Visible = false
	end
	if objects.HealthBar then
		objects.HealthBar.Visible = false
	end
	if objects.HealthGreen then
		objects.HealthGreen.Visible = false
	end
	if objects.HealthText then
		objects.HealthText.Visible = false
	end
	if objects.Distance then
		objects.Distance.Visible = false
	end
	if objects.Skeleton then
		for _, line in pairs(objects.Skeleton) do
			if line then
				line.Visible = false
			end
		end
	end
	if objects.Chams then
		objects.Chams.Enabled = false
	end
	if objects.Eye then
		objects.Eye.Visible = false
	end
end

-- Проверка видимости через стену
local function isVisibleThroughWall(character)
	if not character or not character:FindFirstChild("HumanoidRootPart") then return false end
	local origin = Camera.CFrame.Position
	local target = character.HumanoidRootPart.Position
	local direction = (target - origin).Unit * (target - origin).Magnitude + 10 -- Добавляем небольшой буфер
	local ray = Ray.new(origin, direction)
	local ignoreList = {LocalPlayer.Character, character, workspace.Terrain}
	local part, _ = workspace:FindPartOnRayWithIgnoreList(ray, ignoreList, false, true)
	return not part or (part and part:IsDescendantOf(character))
end

-- Обновление ESP для игрока
local function updateESP(player)
	if not ESPSettings.Enabled or player == LocalPlayer then
		if ESPObjects[player] then
			hideAllObjects(ESPObjects[player])
		end
		return
	end

	if not ESPObjects[player] then
		ESPObjects[player] = {}
	end

	local objects = ESPObjects[player]
	hideAllObjects(objects)

	local character = player.Character
	if not character or not character:FindFirstChild("HumanoidRootPart") or not character:FindFirstChild("Humanoid") then
		return
	end

	local rootPart = character.HumanoidRootPart
	local humanoid = character.Humanoid
	local distance = (LocalPlayer.Character and LocalPlayer.Character.HumanoidRootPart and (rootPart.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude) or math.huge

	-- Проверка на кого показывать ESP
	if ESPSettings.VisibilityMode == "None" then
		return
	elseif ESPSettings.VisibilityMode == "Team" and player.Team ~= LocalPlayer.Team then
		return
	elseif ESPSettings.VisibilityMode == "Enemy" and player.Team == LocalPlayer.Team then
		return
	end

	if distance > ESPSettings.MaxDistance then
		return
	end

	local humPos, onScreen = Camera:WorldToViewportPoint(rootPart.Position)
	if not onScreen or humPos.Z < 0 then
		return
	end

	local headPos, headOnScreen = Camera:WorldToViewportPoint(character:FindFirstChild("Head") and character.Head.Position or rootPart.Position)
	if not headOnScreen or headPos.Z < 0 then
		return
	end

	local distanceY = math.clamp((Vector2.new(headPos.X, headPos.Y) - Vector2.new(humPos.X, humPos.Y)).Magnitude, 2, math.huge)
	local isVisibleWall = isVisibleThroughWall(character)

	-- Box (2D)
	if ESPSettings.Box and ESPSettings.BoxType == "2D" then
		if ESPSettings.BoxStyle == "Default" then
			if not objects.Box then
				objects.Box = NewQuad(ESPSettings.BoxThickness, ESPSettings.BoxColor)
			end
			local function setBoxPoints(quad)
				quad.PointA = Vector2.new(humPos.X + distanceY, humPos.Y - distanceY * 2)
				quad.PointB = Vector2.new(humPos.X - distanceY, humPos.Y - distanceY * 2)
				quad.PointC = Vector2.new(humPos.X - distanceY, humPos.Y + distanceY * 2)
				quad.PointD = Vector2.new(humPos.X + distanceY, humPos.Y + distanceY * 2)
			end
			setBoxPoints(objects.Box)
			if ESPSettings.VisibilityStyle == "Smart" then
				objects.Box.Color = ESPSettings.BoxColor
				objects.Box.Visible = true
			else
				objects.Box.Color = isVisibleWall and ESPSettings.VisibilityDefaultColor or ESPSettings.BoxColor
				objects.Box.Visible = true
			end
		elseif ESPSettings.BoxStyle == "Modern" then
			if not objects.BoxCorners then
				objects.BoxCorners = {
					TopLeftH = NewLine(ESPSettings.BoxThickness, ESPSettings.BoxColor),
					TopLeftV = NewLine(ESPSettings.BoxThickness, ESPSettings.BoxColor),
					TopRightH = NewLine(ESPSettings.BoxThickness, ESPSettings.BoxColor),
					TopRightV = NewLine(ESPSettings.BoxThickness, ESPSettings.BoxColor),
					BottomLeftH = NewLine(ESPSettings.BoxThickness, ESPSettings.BoxColor),
					BottomLeftV = NewLine(ESPSettings.BoxThickness, ESPSettings.BoxColor),
					BottomRightH = NewLine(ESPSettings.BoxThickness, ESPSettings.BoxColor),
					BottomRightV = NewLine(ESPSettings.BoxThickness, ESPSettings.BoxColor)
				}
			end
			local cornerLength = distanceY * 0.4
			local overlap = 1
			local topLeft = Vector2.new(humPos.X - distanceY, humPos.Y - distanceY * 2)
			local topRight = Vector2.new(humPos.X + distanceY, humPos.Y - distanceY * 2)
			local bottomLeft = Vector2.new(humPos.X - distanceY, humPos.Y + distanceY * 2)
			local bottomRight = Vector2.new(humPos.X + distanceY, humPos.Y + distanceY * 2)

			objects.BoxCorners.TopLeftH.From = topLeft - Vector2.new(overlap, 0)
			objects.BoxCorners.TopLeftH.To = topLeft + Vector2.new(cornerLength, 0)
			objects.BoxCorners.TopLeftV.From = topLeft - Vector2.new(0, overlap)
			objects.BoxCorners.TopLeftV.To = topLeft + Vector2.new(0, cornerLength)

			objects.BoxCorners.TopRightH.From = topRight + Vector2.new(overlap, 0)
			objects.BoxCorners.TopRightH.To = topRight - Vector2.new(cornerLength, 0)
			objects.BoxCorners.TopRightV.From = topRight - Vector2.new(0, overlap)
			objects.BoxCorners.TopRightV.To = topRight + Vector2.new(0, cornerLength)

			objects.BoxCorners.BottomLeftH.From = bottomLeft - Vector2.new(overlap, 0)
			objects.BoxCorners.BottomLeftH.To = bottomLeft + Vector2.new(cornerLength, 0)
			objects.BoxCorners.BottomLeftV.From = bottomLeft + Vector2.new(0, overlap)
			objects.BoxCorners.BottomLeftV.To = bottomLeft - Vector2.new(0, cornerLength)

			objects.BoxCorners.BottomRightH.From = bottomRight + Vector2.new(overlap, 0)
			objects.BoxCorners.BottomRightH.To = bottomRight - Vector2.new(cornerLength, 0)
			objects.BoxCorners.BottomRightV.From = bottomRight + Vector2.new(0, overlap)
			objects.BoxCorners.BottomRightV.To = bottomRight - Vector2.new(0, cornerLength)

			if ESPSettings.VisibilityStyle == "Smart" then
				for key, line in pairs(objects.BoxCorners) do
					line.Color = ESPSettings.BoxColor
					line.Thickness = ESPSettings.BoxThickness
					line.Visible = true
				end
			else
				local color = isVisibleWall and ESPSettings.VisibilityDefaultColor or ESPSettings.BoxColor
				for key, line in pairs(objects.BoxCorners) do
					line.Color = color
					line.Thickness = ESPSettings.BoxThickness
					line.Visible = true
				end
			end
		end
	elseif ESPSettings.Box and ESPSettings.BoxType == "3D" then
		if ESPSettings.Box3DStyle == "Fill" then
			if not objects.Box3D then
				local box, container = create3DBoxFill(character)
				if box then
					objects.Box3D = box
					objects.Box3DContainer = container
				end
			end
			if objects.Box3D then
				objects.Box3D.Color3 = ESPSettings.BoxColor
				objects.Box3D.Visible = true
			end
		else -- Default (только линии)
			if not objects.Box3DDefault or not objects.Box3DSize then
				local lines, size = create3DBoxDefault(character)
				objects.Box3DDefault = lines
				objects.Box3DSize = size
			end
			local size = objects.Box3DSize
			local halfSize = size / 2
			local rootPos = rootPart.Position
			local rootCFrame = rootPart.CFrame
			local cornerPositions = {
				(rootCFrame * Vector3.new(-halfSize.X, -halfSize.Y, -halfSize.Z)),
				(rootCFrame * Vector3.new(halfSize.X, -halfSize.Y, -halfSize.Z)),
				(rootCFrame * Vector3.new(halfSize.X, -halfSize.Y, halfSize.Z)),
				(rootCFrame * Vector3.new(-halfSize.X, -halfSize.Y, halfSize.Z)),
				(rootCFrame * Vector3.new(-halfSize.X, halfSize.Y, -halfSize.Z)),
				(rootCFrame * Vector3.new(halfSize.X, halfSize.Y, -halfSize.Z)),
				(rootCFrame * Vector3.new(halfSize.X, halfSize.Y, halfSize.Z)),
				(rootCFrame * Vector3.new(-halfSize.X, halfSize.Y, halfSize.Z))
			}
			local corners = {}
			for i, pos in ipairs(cornerPositions) do
				local screenPos, onScreen = Camera:WorldToViewportPoint(pos)
				corners[i] = { screenPos, onScreen }
			end
			local edges = {
				{1, 2}, {2, 3}, {3, 4}, {4, 1},
				{5, 6}, {6, 7}, {7, 8}, {8, 5},
				{1, 5}, {2, 6}, {3, 7}, {4, 8}
			}
			for i, edge in ipairs(edges) do
				local pos1, vis1 = corners[edge[1]][1], corners[edge[1]][2]
				local pos2, vis2 = corners[edge[2]][1], corners[edge[2]][2]
				local line = objects.Box3DDefault["Edge" .. i]
				if vis1 and vis2 then
					line.From = Vector2.new(pos1.X, pos1.Y)
					line.To = Vector2.new(pos2.X, pos2.Y)
					line.Color = ESPSettings.BoxColor
					line.Thickness = ESPSettings.BoxThickness
					line.Visible = true
				else
					line.Visible = false
				end
			end
		end
	end

	-- Name
	if ESPSettings.Name then
		if not objects.Name then
			objects.Name = NewText()
		end
		objects.Name.Text = player.Name
		objects.Name.Position = Vector2.new(humPos.X, humPos.Y - distanceY * 2 - 20)
		objects.Name.Color = ESPSettings.NameColor
		objects.Name.Visible = true
	else
		if objects.Name then
			objects.Name.Visible = false
		end
	end

	-- Health
	if ESPSettings.Health then
		if not objects.HealthBar then
			objects.HealthBar = NewLine(3, Color3.fromRGB(0, 0, 0))
		end
		if not objects.HealthGreen then
			objects.HealthGreen = NewLine(1.5, ESPSettings.HealthColor)
		end
		if not objects.HealthText then
			objects.HealthText = NewText()
		end
		local healthPercent = humanoid.Health / humanoid.MaxHealth
		local healthColor = Color3.fromRGB(255 * (1 - healthPercent), 255 * healthPercent, 0)
		local d = (Vector2.new(humPos.X - distanceY, humPos.Y - distanceY * 2) - Vector2.new(humPos.X - distanceY, humPos.Y + distanceY * 2)).Magnitude
		local healthOffset = healthPercent * d
		objects.HealthBar.From = Vector2.new(humPos.X - distanceY - 4, humPos.Y + distanceY * 2)
		objects.HealthBar.To = Vector2.new(humPos.X - distanceY - 4, humPos.Y - distanceY * 2)
		objects.HealthBar.Visible = true
		objects.HealthGreen.From = Vector2.new(humPos.X - distanceY - 4, humPos.Y + distanceY * 2)
		objects.HealthGreen.To = Vector2.new(humPos.X - distanceY - 4, humPos.Y + distanceY * 2 - healthOffset)
		objects.HealthGreen.Color = healthColor
		objects.HealthGreen.Visible = true
		objects.HealthText.Text = tostring(math.floor(humanoid.Health))
		objects.HealthText.Position = Vector2.new(humPos.X - distanceY - 4, humPos.Y + distanceY * 2 + 15)
		objects.HealthText.Color = ESPSettings.HealthColor
		objects.HealthText.Visible = true
	else
		if objects.HealthBar then
			objects.HealthBar.Visible = false
		end
		if objects.HealthGreen then
			objects.HealthGreen.Visible = false
		end
		if objects.HealthText then
			objects.HealthText.Visible = false
		end
	end

	-- Distance
	if ESPSettings.Distance then
		if not objects.Distance then
			objects.Distance = NewText()
		end
		objects.Distance.Text = math.floor(distance) .. " studs"
		local offset = ESPSettings.Health and 30 or 15
		objects.Distance.Position = Vector2.new(humPos.X, humPos.Y + distanceY * 2 + offset)
		objects.Distance.Color = ESPSettings.DistanceColor
		objects.Distance.Visible = true
	else
		if objects.Distance then
			objects.Distance.Visible = false
		end
	end

	-- Skeleton
	if ESPSettings.Skeleton then
		if not objects.Skeleton then
			objects.Skeleton = createSkeleton(player)
		end
		local rigType = character.Humanoid.RigType == Enum.HumanoidRigType.R15 and "R15" or "R6"
		local connections = {
			R6 = {
				{"Head", "Torso"},
				{"Torso", "Left Arm"},
				{"Torso", "Right Arm"},
				{"Torso", "Left Leg"},
				{"Torso", "Right Leg"}
			},
			R15 = {
				{"Head", "UpperTorso"},
				{"UpperTorso", "LowerTorso"},
				{"UpperTorso", "LeftUpperArm"},
				{"LeftUpperArm", "LeftLowerArm"},
				{"LeftLowerArm", "LeftHand"},
				{"UpperTorso", "RightUpperArm"},
				{"RightUpperArm", "RightLowerArm"},
				{"RightLowerArm", "RightHand"},
				{"LowerTorso", "LeftUpperLeg"},
				{"LeftUpperLeg", "LeftLowerLeg"},
				{"LeftLowerLeg", "LeftFoot"},
				{"LowerTorso", "RightUpperLeg"},
				{"RightUpperLeg", "RightLowerLeg"},
				{"RightLowerLeg", "RightFoot"}
			}
		}
		for _, pair in ipairs(connections[rigType]) do
			local line = objects.Skeleton[pair[1] .. "_" .. pair[2]]
			if line then
				local part1 = character:FindFirstChild(pair[1])
				local part2 = character:FindFirstChild(pair[2])
				if part1 and part2 then
					local pos1, vis1 = Camera:WorldToViewportPoint(part1.Position)
					local pos2, vis2 = Camera:WorldToViewportPoint(part2.Position)
					local pos1Visible = vis1 and pos1.Z > 0
					local pos2Visible = vis2 and pos2.Z > 0
					if pos1Visible and pos2Visible then
						line.From = Vector2.new(pos1.X, pos1.Y)
						line.To = Vector2.new(pos2.X, pos2.Y)
						line.Color = ESPSettings.SkeletonColor
						line.Visible = true
					else
						line.Visible = false
					end
				else
					line.Visible = false
				end
			end
		end
	else
		if objects.Skeleton then
			for _, line in pairs(objects.Skeleton) do
				line.Visible = false
			end
		end
	end

	-- Chams
	if ESPSettings.Chams then
		if not objects.Chams then
			objects.Chams = createChams(character)
		end
		objects.Chams.FillColor = ESPSettings.ChamsColor
		objects.Chams.OutlineColor = ESPSettings.ChamsColor
		objects.Chams.Enabled = true
	else
		if objects.Chams then
			objects.Chams.Enabled = false
		end
	end

	-- Visible Check
	if ESPSettings.VisibleCheck then
		if not objects.Eye then
			objects.Eye = NewEye()
		end
		objects.Eye.Position = Vector2.new(humPos.X, humPos.Y - distanceY * 2 - 40)
		objects.Eye.Color = isVisibleWall and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
		objects.Eye.Visible = true
	else
		if objects.Eye then
			objects.Eye.Visible = false
		end
	end
end

function ESP:Load()
	-- Обновление ESP для всех игроков
	RunService.RenderStepped:Connect(function()
		for _, player in ipairs(Players:GetPlayers()) do
			updateESP(player)
		end
	end)

	-- Обработка добавления/удаления игроков
	Players.PlayerAdded:Connect(function(player)
		if player ~= LocalPlayer then
			player.CharacterAdded:Connect(function()
				updateESP(player)
			end)
		end
	end)

	Players.PlayerRemoving:Connect(function(player)
		clearPlayerObjects(player)
	end)

	-- Инициализация ESP для существующих игроков
	for _, player in ipairs(Players:GetPlayers()) do
		if player ~= LocalPlayer then
			if player.Character then
				updateESP(player)
			end
			player.CharacterAdded:Connect(function()
				updateESP(player)
			end)
		end
	end

	-- Интерфейс для вкладки Visual
	VisualTab:Separator({Text = "ESP Настройки"})

	VisualTab:Checkbox({
		IniFlag = "ESP_Enabled",
		Label = "ESP On",
		Value = ESPSettings.Enabled,
		Callback = function(self, value)
			ESPSettings.Enabled = value
			for _, player in ipairs(Players:GetPlayers()) do
				if ESPObjects[player] then
					hideAllObjects(ESPObjects[player])
				end
				updateESP(player)
			end
		end
	})

	VisualTab:Checkbox({
		IniFlag = "ESP_Box",
		Label = "Box",
		Value = ESPSettings.Box,
		Callback = function(self, value)
			ESPSettings.Box = value
			for _, player in ipairs(Players:GetPlayers()) do
				if ESPObjects[player] then
					hideAllObjects(ESPObjects[player])
				end
				updateESP(player)
			end
		end
	})

	local BoxTypeCombo = VisualTab:Combo({
		IniFlag = "ESP_BoxType",
		Label = "Box Type",
		Selected = ESPSettings.BoxType,
		Items = {"None", "2D", "3D"},
		Callback = function(self, value)
			ESPSettings.BoxType = value
			for _, player in ipairs(Players:GetPlayers()) do
				if ESPObjects[player] then
					hideAllObjects(ESPObjects[player])
				end
				updateESP(player)
			end
		end
	})

	local BoxStyleCombo = VisualTab:Combo({
		IniFlag = "ESP_BoxStyle",
		Label = "2D Box Style",
		Selected = ESPSettings.BoxStyle,
		Items = {"Default", "Modern"},
		Callback = function(self, value)
			ESPSettings.BoxStyle = value
			for _, player in ipairs(Players:GetPlayers()) do
				if ESPObjects[player] then
					hideAllObjects(ESPObjects[player])
				end
				updateESP(player)
			end
		end
	})

	local Box3DStyleCombo = VisualTab:Combo({
		IniFlag = "ESP_Box3DStyle",
		Label = "3D Box Style",
		Selected = ESPSettings.Box3DStyle,
		Items = {"Fill", "Default"},
		Callback = function(self, value)
			ESPSettings.Box3DStyle = value
			for _, player in ipairs(Players:GetPlayers()) do
				if ESPObjects[player] then
					hideAllObjects(ESPObjects[player])
				end
				updateESP(player)
			end
		end
	})

	RunService.Heartbeat:Connect(function()
		BoxStyleCombo.Visible = ESPSettings.BoxType == "2D"
		Box3DStyleCombo.Visible = ESPSettings.BoxType == "3D"
	end)

	VisualTab:Combo({
		IniFlag = "ESP_VisibilityMode",
		Label = "Show ESP On",
		Selected = ESPSettings.VisibilityMode,
		Items = {"None", "All", "Team", "Enemy"},
		Callback = function(self, value)
			ESPSettings.VisibilityMode = value
			for _, player in ipairs(Players:GetPlayers()) do
				if ESPObjects[player] then
					hideAllObjects(ESPObjects[player])
				end
				updateESP(player)
			end
		end
	})

	VisualTab:Checkbox({
		IniFlag = "ESP_VisibleCheck",
		Label = "Visible Check",
		Value = ESPSettings.VisibleCheck,
		Callback = function(self, value)
			ESPSettings.VisibleCheck = value
			for _, player in ipairs(Players:GetPlayers()) do
				updateESP(player)
			end
		end
	})

	local VisibilityStyleCombo = VisualTab:Combo({
		IniFlag = "ESP_VisibilityStyle",
		Label = "Visibility Style",
		Selected = ESPSettings.VisibilityStyle,
		Items = {"Smart", "Default"},
		Callback = function(self, value)
			ESPSettings.VisibilityStyle = value
			for _, player in ipairs(Players:GetPlayers()) do
				if ESPObjects[player] then
					hideAllObjects(ESPObjects[player]) -- Полное скрытие перед обновлением
				end
				updateESP(player)
			end
		end
	})

	local VisibilityColorInput = VisualTab:InputColor3({
		IniFlag = "ESP_VisibilityDefaultColor",
		Label = "Default Visibility Color",
		Value = ESPSettings.VisibilityDefaultColor,
		Callback = function(self, value)
			ESPSettings.VisibilityDefaultColor = value
			for _, player in ipairs(Players:GetPlayers()) do
				if ESPObjects[player] then
					if ESPObjects[player].Box then
						objects.Box.Color = isVisibleThroughWall(player.Character) and value or ESPSettings.BoxColor
					end
					if ESPObjects[player].BoxCorners then
						for key, line in pairs(ESPObjects[player].BoxCorners) do
							line.Color = isVisibleThroughWall(player.Character) and value or ESPSettings.BoxColor
						end
					end
				end
			end
		end
	})

	RunService.Heartbeat:Connect(function()
		VisibilityColorInput.Visible = ESPSettings.VisibilityStyle == "Default" and ESPSettings.Box
	end)

	VisualTab:Checkbox({
		IniFlag = "ESP_Name",
		Label = "Name",
		Value = ESPSettings.Name,
		Callback = function(self, value)
			ESPSettings.Name = value
			for _, player in ipairs(Players:GetPlayers()) do
				updateESP(player)
			end
		end
	})

	VisualTab:Checkbox({
		IniFlag = "ESP_Health",
		Label = "Health",
		Value = ESPSettings.Health,
		Callback = function(self, value)
			ESPSettings.Health = value
			for _, player in ipairs(Players:GetPlayers()) do
				updateESP(player)
			end
		end
	})

	VisualTab:Checkbox({
		IniFlag = "ESP_Distance",
		Label = "Distance",
		Value = ESPSettings.Distance,
		Callback = function(self, value)
			ESPSettings.Distance = value
			for _, player in ipairs(Players:GetPlayers()) do
				updateESP(player)
			end
		end
	})

	VisualTab:Checkbox({
		IniFlag = "ESP_Skeleton",
		Label = "Skeleton",
		Value = ESPSettings.Skeleton,
		Callback = function(self, value)
			ESPSettings.Skeleton = value
			for _, player in ipairs(Players:GetPlayers()) do
				updateESP(player)
			end
		end
	})

	VisualTab:Checkbox({
		IniFlag = "ESP_Chams",
		Label = "Chams",
		Value = ESPSettings.Chams,
		Callback = function(self, value)
			ESPSettings.Chams = value
			for _, player in ipairs(Players:GetPlayers()) do
				updateESP(player)
			end
		end
	})

	VisualTab:SliderInt({
		IniFlag = "ESP_MaxDistance",
		Label = "Max Distance",
		Value = ESPSettings.MaxDistance,
		Minimum = 100,
		Maximum = 5000,
		Callback = function(self, value)
			ESPSettings.MaxDistance = value
			for _, player in ipairs(Players:GetPlayers()) do
				updateESP(player)
			end
		end
	})

	-- Выбор цветов
	VisualTab:Separator({Text = "Настройка цветов"})

	VisualTab:Label({Text = "Box Color: Цвет рамки или углов вокруг игрока (2D/3D)"})
	VisualTab:InputColor3({
		IniFlag = "ESP_BoxColor",
		Label = "Box Color",
		Value = ESPSettings.BoxColor,
		Callback = function(self, value)
			ESPSettings.BoxColor = value
			for _, player in ipairs(Players:GetPlayers()) do
				if ESPObjects[player] then
					if ESPObjects[player].Box then
						objects.Box.Color = isVisibleThroughWall(player.Character) and ESPSettings.VisibilityDefaultColor or value
					end
					if ESPObjects[player].BoxCorners then
						for key, line in pairs(ESPObjects[player].BoxCorners) do
							line.Color = isVisibleThroughWall(player.Character) and ESPSettings.VisibilityDefaultColor or value
						end
					end
					if ESPObjects[player].Box3D then
						ESPObjects[player].Box3D.Color3 = value
					end
					if ESPObjects[player].Box3DDefault then
						for _, line in pairs(ESPObjects[player].Box3DDefault) do
							line.Color = value
						end
					end
				end
			end
		end
	})

	VisualTab:Label({Text = "Name Color: Цвет ника игрока над боксом"})
	VisualTab:InputColor3({
		IniFlag = "ESP_NameColor",
		Label = "Name Color",
		Value = ESPSettings.NameColor,
		Callback = function(self, value)
			ESPSettings.NameColor = value
			for _, player in ipairs(Players:GetPlayers()) do
				if ESPObjects[player] and ESPObjects[player].Name then
					ESPObjects[player].Name.Color = value
				end
			end
		end
	})

	VisualTab:Label({Text = "Health Base Color: Базовый цвет полоски здоровья (меняется от красного к зелёному)"})
	VisualTab:InputColor3({
		IniFlag = "ESP_HealthColor",
		Label = "Health Base Color",
		Value = ESPSettings.HealthColor,
		Callback = function(self, value)
			ESPSettings.HealthColor = value
			for _, player in ipairs(Players:GetPlayers()) do
				if ESPObjects[player] and ESPObjects[player].HealthText then
					ESPObjects[player].HealthText.Color = value
				end
			end
		end
	})

	VisualTab:Label({Text = "Distance Color: Цвет текста дистанции под боксом"})
	VisualTab:InputColor3({
		IniFlag = "ESP_DistanceColor",
		Label = "Distance Color",
		Value = ESPSettings.DistanceColor,
		Callback = function(self, value)
			ESPSettings.DistanceColor = value
			for _, player in ipairs(Players:GetPlayers()) do
				if ESPObjects[player] and ESPObjects[player].Distance then
					ESPObjects[player].Distance.Color = value
				end
			end
		end
	})

	VisualTab:Label({Text = "Skeleton Color: Цвет линий скелета игрока"})
	VisualTab:InputColor3({
		IniFlag = "ESP_SkeletonColor",
		Label = "Skeleton Color",
		Value = ESPSettings.SkeletonColor,
		Callback = function(self, value)
			ESPSettings.SkeletonColor = value
			for _, player in ipairs(Players:GetPlayers()) do
				if ESPObjects[player] and ESPObjects[player].Skeleton then
					for _, line in pairs(ESPObjects[player].Skeleton) do
						line.Color = value
					end
				end
			end
		end
	})

	VisualTab:Label({Text = "Chams Color: Цвет подсветки модели игрока"})
	VisualTab:InputColor3({
		IniFlag = "ESP_ChamsColor",
		Label = "Chams Color",
		Value = ESPSettings.ChamsColor,
		Callback = function(self, value)
			ESPSettings.ChamsColor = value
			for _, player in ipairs(Players:GetPlayers()) do
				if ESPObjects[player] and ESPObjects[player].Chams then
					ESPObjects[player].Chams.FillColor = value
					ESPObjects[player].Chams.OutlineColor = value
				end
			end
		end
	})
end

return ESP
