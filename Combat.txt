-- Combat модуль
local CombatContent = nil
local initialized = false

-- Импорт необходимых сервисов и функций
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")

local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera

local GetPlayers = Players.GetPlayers
local WorldToScreen = Camera.WorldToScreenPoint
local WorldToViewportPoint = Camera.WorldToViewportPoint
local FindFirstChild = game.FindFirstChild
local RenderStepped = RunService.RenderStepped
local GetMouseLocation = UserInputService.GetMouseLocation

-- Определение функций coroutine
local resume = coroutine.resume 
local create = coroutine.create

-- Team Relations
local TeamRelations = {
    ["Class D"] = { Allies = {"Chaos Insurgency"}, Enemies = {"Mobile Task Force", "Scientist", "SCP"} },
    ["Chaos Insurgency"] = { Allies = {"Class D"}, Enemies = {"Mobile Task Force", "Scientist", "SCP"} },
    ["Scientist"] = { Allies = {"Mobile Task Force"}, Enemies = {"Class D", "Chaos Insurgency", "SCP"} },
    ["Mobile Task Force"] = { Allies = {"Scientist"}, Enemies = {"Class D", "Chaos Insurgency", "SCP"} },
    ["SCP"] = { Allies = {}, Enemies = {"Class D", "Chaos Insurgency", "Mobile Task Force", "Scientist"} }
}

-- Функция получения роли игрока
local function getPlayerRole(player)
    if not player then return "Unknown" end
    local team = player.Team
    return team and team.Name or "Unknown"
end

-- Notifications
local showNotification
local notifSuccess, notifError = pcall(function()
    showNotification = loadstring(game:HttpGet("https://raw.githubusercontent.com/sergeytwwwe/VeryUp/refs/heads/main/VeryUpNotifications"))()
end)
if not notifSuccess then
    warn("Failed to load VeryUpNotifications: " .. notifError)
    showNotification = function(message, isError)
        if isError then
            warn("[Notification] " .. message)
        else
            print("[Notification] " .. message)
        end
    end
end

-- Silent Aim Section
local SilentAimSettings = {
    Enabled = false,
    Mode = "Switch",
    UseFOV = false,
    VisFOV = false,
    ShowTarget = false,
    WallCheck = false,
    TeamCheck = false,
    FOVRadius = 360,
    TargetPart = "Head",
    SilentAimMethod = "Raycast",
    IsKeyHeld = false,
    Bind = Enum.KeyCode.T,
    CurrentTarget = nil
}

-- Drawing
local silent_fov_circle = Drawing.new("Circle")
silent_fov_circle.Thickness = 1
silent_fov_circle.NumSides = 1000
silent_fov_circle.Radius = SilentAimSettings.FOVRadius
silent_fov_circle.Filled = false
silent_fov_circle.Visible = false
silent_fov_circle.ZIndex = 999
silent_fov_circle.Transparency = 1
silent_fov_circle.Color = Color3.fromRGB(255, 255, 255)

local target_box = Drawing.new("Square")
target_box.Visible = false
target_box.ZIndex = 999
target_box.Color = Color3.fromRGB(255, 255, 255)
target_box.Thickness = 4
target_box.Size = Vector2.new(10, 10)
target_box.Filled = false
target_box.CornerRadius = 0.3
target_box.Transparency = 1

-- Functions
local function getPositionOnScreen(Vector)
    local Vec3, OnScreen = WorldToScreen(Camera, Vector)
    return Vector2.new(Vec3.X, Vec3.Y), OnScreen
end

local function getDirection(Origin, Position)
    return (Position - Origin).Unit * 1000
end

local function getMousePosition()
    return GetMouseLocation(UserInputService)
end

-- Флаг для предотвращения рекурсии в Wall Check
local isCheckingWall = false

-- Wall Check с Raycast, как в Wallcheck.txt
local function checkWall(Player, settings)
    if isCheckingWall then
        return true
    end

    local PlayerCharacter = Player.Character
    local LocalPlayerCharacter = LocalPlayer.Character
    if not (PlayerCharacter and LocalPlayerCharacter) then return true end

    local targetPart = PlayerCharacter:FindFirstChild(settings.TargetPart)
    if not targetPart then targetPart = PlayerCharacter:FindFirstChild("HumanoidRootPart") end
    if not targetPart then return true end

    isCheckingWall = true

    local origin = Camera.CFrame.Position
    local direction = (targetPart.Position - origin).Unit * (targetPart.Position - origin).Magnitude
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {LocalPlayerCharacter, PlayerCharacter}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist

    local raycastResult = Workspace:Raycast(origin, direction, raycastParams)

    isCheckingWall = false

    return raycastResult and raycastResult.Instance ~= nil
end

-- getClosestPlayer из scp.txt
local function getClosestPlayer(settings)
    local Closest
    local DistanceToMouse = math.huge
    for _, Player in next, GetPlayers(Players) do
        if Player == LocalPlayer then continue end
        local Character = Player.Character
        if not Character then continue end
        if settings.TeamCheck then
            local LocalTeam = getPlayerRole(LocalPlayer)
            local PlayerTeam = getPlayerRole(Player)
            if LocalTeam == "Unknown" or PlayerTeam == "Unknown" then continue end
            local Relations = TeamRelations[LocalTeam]
            if Relations and (table.find(Relations.Allies, PlayerTeam) or LocalTeam == PlayerTeam) then continue end
        end
        if settings.WallCheck and checkWall(Player, settings) then continue end
        local TargetPart = FindFirstChild(Character, settings.TargetPart)
        if not TargetPart then TargetPart = FindFirstChild(Character, "HumanoidRootPart") end
        local Humanoid = FindFirstChild(Character, "Humanoid")
        if not TargetPart or not Humanoid or Humanoid and Humanoid.Health <= 0 then continue end
        local ScreenPosition, OnScreen = getPositionOnScreen(TargetPart.Position)
        if not OnScreen then continue end
        local Distance = (getMousePosition() - ScreenPosition).Magnitude
        if Distance <= (settings.FOVRadius or math.huge) and Distance < DistanceToMouse then
            Closest = TargetPart
            DistanceToMouse = Distance
            settings.CurrentTarget = Player
        end
    end
    return Closest
end

-- Silent Aim из scp.txt с защитой от рекурсии
local ExpectedArguments = {
    Raycast = {
        ArgCountRequired = 3,
        Args = {
            "Instance", "Vector3", "Vector3", "RaycastParams"
        }
    }
}

local function ValidateArguments(Args, RayMethod)
    local Matches = 0
    if #Args < RayMethod.ArgCountRequired then
        return false
    end
    for Pos, Argument in next, Args do
        if typeof(Argument) == RayMethod.Args[Pos] then
            Matches = Matches + 1
        end
    end
    return Matches >= RayMethod.ArgCountRequired
end

-- Флаг для предотвращения рекурсии в Silent Aim
local isProcessingSilentAim = false

local oldNamecall
oldNamecall = hookmetamethod(game, "__namecall", newcclosure(function(...)
    if isCheckingWall then
        return oldNamecall(...)
    end

    if isProcessingSilentAim then
        return oldNamecall(...)
    end

    local Method = getnamecallmethod()
    local Arguments = {...}
    local self = Arguments[1]
    local isActive = SilentAimSettings.Enabled or (SilentAimSettings.Mode == "Retention" and SilentAimSettings.IsKeyHeld)

    if isActive and self == Workspace and not checkcaller() then
        if Method == "Raycast" and SilentAimSettings.SilentAimMethod == "Raycast" then
            if ValidateArguments(Arguments, ExpectedArguments.Raycast) then
                isProcessingSilentAim = true
                local A_Origin = Arguments[2]
                local HitPart = getClosestPlayer(SilentAimSettings)
                if HitPart then
                    Arguments[3] = getDirection(A_Origin, HitPart.Position)
                    local result = oldNamecall(unpack(Arguments))
                    isProcessingSilentAim = false
                    return result
                end
                isProcessingSilentAim = false
            end
        end
    end
    return oldNamecall(...)
end))

-- Инициализация UI перед использованием
local SilentAimEnableCheckbox

local function initializeUI()
    if not CombatContent or initialized then return end
    initialized = true

    local SilentAimHeader = CombatContent:CollapsingHeader({Title = "Silent Aim"})
    SilentAimEnableCheckbox = SilentAimHeader:Checkbox({
        IniFlag = "SilentAim_Enabled",
        Label = "Silent Aim Enable",
        Value = SilentAimSettings.Enabled,
        Callback = function(self, value)
            SilentAimSettings.Enabled = value
            SilentAimSettings.IsKeyHeld = false
        end
    })

    SilentAimHeader:Combo({
        IniFlag = "SilentAim_Mode",
        Label = "Mode",
        Selected = SilentAimSettings.Mode,
        Items = {"Switch", "Retention"},
        Callback = function(self, value)
            SilentAimSettings.Mode = value
            SilentAimSettings.Enabled = false
            SilentAimSettings.IsKeyHeld = false
        end
    })

    SilentAimHeader:Checkbox({
        IniFlag = "SilentAim_UseFOV",
        Label = "Use FOV",
        Value = SilentAimSettings.UseFOV,
        Callback = function(self, value)
            SilentAimSettings.UseFOV = value
        end
    })

    SilentAimHeader:Checkbox({
        IniFlag = "SilentAim_VisFOV",
        Label = "Vis FOV",
        Value = SilentAimSettings.VisFOV,
        Callback = function(self, value)
            SilentAimSettings.VisFOV = value
        end
    })

    SilentAimHeader:SliderInt({
        IniFlag = "SilentAim_FOVRadius",
        Label = "FOV Size",
        Value = SilentAimSettings.FOVRadius,
        Minimum = 0,
        Maximum = 360,
        Callback = function(self, value)
            SilentAimSettings.FOVRadius = value
        end
    })

    SilentAimHeader:Checkbox({
        IniFlag = "SilentAim_ShowTarget",
        Label = "Show Target",
        Value = SilentAimSettings.ShowTarget,
        Callback = function(self, value)
            SilentAimSettings.ShowTarget = value
        end
    })

    SilentAimHeader:Checkbox({
        IniFlag = "SilentAim_WallCheck",
        Label = "Wall Check",
        Value = SilentAimSettings.WallCheck,
        Callback = function(self, value)
            SilentAimSettings.WallCheck = value
        end
    })

    SilentAimHeader:Checkbox({
        IniFlag = "SilentAim_TeamCheck",
        Label = "Team Check",
        Value = SilentAimSettings.TeamCheck,
        Callback = function(self, value)
            SilentAimSettings.TeamCheck = value
        end
    })

    SilentAimHeader:Keybind({
        IniFlag = "SilentAim_Bind",
        Label = "Bind",
        Value = SilentAimSettings.Bind,
        Callback = function(self, value)
            SilentAimSettings.Bind = value
        end
    })

    SilentAimHeader:Combo({
        IniFlag = "SilentAim_TargetPart",
        Label = "Target Part",
        Selected = SilentAimSettings.TargetPart,
        Items = {"Head", "HumanoidRootPart"},
        Callback = function(self, value)
            SilentAimSettings.TargetPart = value
        end
    })
end

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == SilentAimSettings.Bind then
        if SilentAimSettings.Mode == "Switch" then
            SilentAimSettings.Enabled = not SilentAimSettings.Enabled
            SilentAimSettings.IsKeyHeld = false
        elseif SilentAimSettings.Mode == "Retention" then
            SilentAimSettings.IsKeyHeld = true
            SilentAimSettings.Enabled = false
        end
    end
end)

UserInputService.InputEnded:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == SilentAimSettings.Bind and SilentAimSettings.Mode == "Retention" then
        SilentAimSettings.IsKeyHeld = false
    end
end)

local targetAlpha = 0
local silentColorTransition = 0
resume(create(function()
    RenderStepped:Connect(function()
        silent_fov_circle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
        silent_fov_circle.Radius = SilentAimSettings.FOVRadius
        silent_fov_circle.Visible = SilentAimSettings.VisFOV and (SilentAimSettings.Enabled or SilentAimSettings.IsKeyHeld)
        local ClosestSilent = getClosestPlayer(SilentAimSettings)
        if (SilentAimSettings.Enabled or SilentAimSettings.IsKeyHeld) and ClosestSilent then
            silentColorTransition = math.min(silentColorTransition + 0.05, 1)
        else
            silentColorTransition = math.max(silentColorTransition - 0.05, 0)
        end
        local sr = 255 - (silentColorTransition * 255)
        local sg = 255 - (silentColorTransition * 255)
        local sb = 255 - (silentColorTransition * 255)
        silent_fov_circle.Color = Color3.fromRGB(sr, sg, sb)

        if SilentAimSettings.ShowTarget and (SilentAimSettings.Enabled or SilentAimSettings.IsKeyHeld) then
            if ClosestSilent then
                local TargetPart = FindFirstChild(ClosestSilent.Parent, SilentAimSettings.TargetPart)
                if not TargetPart then TargetPart = FindFirstChild(ClosestSilent.Parent, "HumanoidRootPart") end
                local RootToViewportPoint, IsOnScreen = WorldToViewportPoint(Camera, TargetPart.Position)
                if IsOnScreen then
                    local Distance = (Camera.CFrame.Position - TargetPart.Position).Magnitude
                    local BaseSize = 10
                    local Size = math.max(BaseSize * (50 / math.max(Distance, 1)), 5)
                    target_box.Size = Vector2.new(Size, Size)
                    targetAlpha = 1
                    target_box.Visible = true
                    target_box.Position = Vector2.new(RootToViewportPoint.X, RootToViewportPoint.Y) - Vector2.new(Size / 2, Size / 2)
                else
                    targetAlpha = 0
                    target_box.Visible = false
                end
            else
                targetAlpha = 0
                target_box.Visible = false
            end
        else
            targetAlpha = 0
            target_box.Visible = false
        end
    end)
end))

-- Функция инициализации модуля
return function(content)
    CombatContent = content
    initializeUI()
end