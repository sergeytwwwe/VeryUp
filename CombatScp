-- Combat модуль
local CombatContent = nil
local initialized = false

-- Импорт необходимых сервисов и функций
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")

local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera

local GetPlayers = Players.GetPlayers
local WorldToScreen = Camera.WorldToScreenPoint
local WorldToViewportPoint = Camera.WorldToViewportPoint
local FindFirstChild = game.FindFirstChild
local RenderStepped = RunService.RenderStepped
local GetMouseLocation = UserInputService.GetMouseLocation

-- Определение функций coroutine
local resume = coroutine.resume 
local create = coroutine.create

-- Team Relations
local TeamRelations = {
    ["Class D"] = { Allies = {"Chaos Insurgency"}, Enemies = {"Mobile Task Force", "Scientist", "SCP"} },
    ["Chaos Insurgency"] = { Allies = {"Class D"}, Enemies = {"Mobile Task Force", "Scientist", "SCP"} },
    ["Scientist"] = { Allies = {"Mobile Task Force"}, Enemies = {"Class D", "Chaos Insurgency", "SCP"} },
    ["Mobile Task Force"] = { Allies = {"Scientist"}, Enemies = {"Class D", "Chaos Insurgency", "SCP"} },
    ["SCP"] = { Allies = {}, Enemies = {"Class D", "Chaos Insurgency", "Mobile Task Force", "Scientist"} }
}

-- Функция получения роли игрока
local function getPlayerRole(player)
    if not player then return "Unknown" end
    local team = player.Team
    return team and team.Name or "Unknown"
end

-- Notifications
local showNotification
local notifSuccess, notifError = pcall(function()
    showNotification = loadstring(game:HttpGet("https://raw.githubusercontent.com/sergeytwwwe/VeryUp/refs/heads/main/VeryUpNotifications"))()
end)
if not notifSuccess then
    warn("Failed to load VeryUpNotifications: " .. notifError)
    showNotification = function(message, isError)
        if isError then
            warn("[Notification] " .. message)
        else
            print("[Notification] " .. message)
        end
    end
end

-- Silent Aim Section
local SilentAimSettings = {
    Enabled = false,
    Mode = "Switch",
    UseFOV = false,
    VisFOV = false,
    ShowTarget = false,
    WallCheck = false,
    TeamCheck = false,
    FOVRadius = 360,
    TargetPart = "Head",
    SilentAimMethod = "Raycast",
    IsKeyHeld = false,
    Bind = Enum.KeyCode.T,
    CurrentTarget = nil
}

-- Drawing
local silent_fov_circle = Drawing.new("Circle")
silent_fov_circle.Thickness = 1
silent_fov_circle.NumSides = 1000
silent_fov_circle.Radius = SilentAimSettings.FOVRadius
silent_fov_circle.Filled = false
silent_fov_circle.Visible = false
silent_fov_circle.ZIndex = 999
silent_fov_circle.Transparency = 1
silent_fov_circle.Color = Color3.fromRGB(255, 255, 255)

local target_box = Drawing.new("Square")
target_box.Visible = false
target_box.ZIndex = 999
target_box.Color = Color3.fromRGB(255, 255, 255)
target_box.Thickness = 4
target_box.Size = Vector2.new(10, 10)
target_box.Filled = false
target_box.CornerRadius = 0.3
target_box.Transparency = 1

-- Functions
local function getPositionOnScreen(Vector)
    local Vec3, OnScreen = WorldToScreen(Camera, Vector)
    return Vector2.new(Vec3.X, Vec3.Y), OnScreen
end

local function getDirection(Origin, Position)
    return (Position - Origin).Unit * 1000
end

local function getMousePosition()
    return GetMouseLocation(UserInputService)
end

-- Wall Check с Raycast
local function checkWall(Player, settings)
    local PlayerCharacter = Player.Character
    local LocalPlayerCharacter = LocalPlayer.Character
    if not (PlayerCharacter and LocalPlayerCharacter) then return true end

    local targetPart = PlayerCharacter:FindFirstChild(settings.TargetPart)
    if not targetPart then targetPart = PlayerCharacter:FindFirstChild("HumanoidRootPart") end
    if not targetPart then return true end

    local origin = LocalPlayerCharacter:FindFirstChild("HumanoidRootPart")
    if not origin then return true end
    origin = origin.Position

    local direction = (targetPart.Position - origin).Unit * (targetPart.Position - origin).Magnitude
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {LocalPlayerCharacter, PlayerCharacter}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist

    local raycastResult = Workspace:Raycast(origin, direction, raycastParams)
    return raycastResult and raycastResult.Instance ~= nil
end

-- getClosestPlayer
local function getClosestPlayer(settings)
    local Closest
    local DistanceToMouse = math.huge
    for _, Player in next, GetPlayers(Players) do
        if Player == LocalPlayer then continue end
        local Character = Player.Character
        if not Character then continue end
        if settings.TeamCheck then
            local LocalTeam = getPlayerRole(LocalPlayer)
            local PlayerTeam = getPlayerRole(Player)
            if LocalTeam == "Unknown" or PlayerTeam == "Unknown" then continue end
            local Relations = TeamRelations[LocalTeam]
            if Relations and (table.find(Relations.Allies, PlayerTeam) or LocalTeam == PlayerTeam) then continue end
        end
        if settings.WallCheck and checkWall(Player, settings) then continue end
        local TargetPart = FindFirstChild(Character, settings.TargetPart)
        if not TargetPart then TargetPart = FindFirstChild(Character, "HumanoidRootPart") end
        local Humanoid = FindFirstChild(Character, "Humanoid")
        if not TargetPart or not Humanoid or Humanoid and Humanoid.Health <= 0 then continue end
        local ScreenPosition, OnScreen = getPositionOnScreen(TargetPart.Position)
        if not OnScreen then continue end
        local Distance = (getMousePosition() - ScreenPosition).Magnitude
        if Distance <= (settings.FOVRadius or math.huge) and Distance < DistanceToMouse then
            Closest = TargetPart
            DistanceToMouse = Distance
            settings.CurrentTarget = Player
        end
    end
    return Closest
end

-- Симуляция Raycast для Silent Aim (с позиции персонажа)
local function simulateRaycast(origin, direction, targetPart)
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {LocalPlayer.Character}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist

    -- Проверяем, есть ли препятствия до цели
    local raycastResult = Workspace:Raycast(origin, (targetPart.Position - origin), raycastParams)
    if raycastResult then
        if raycastResult.Instance:IsDescendantOf(targetPart.Parent) then
            return raycastResult
        end
        return nil
    end

    -- Если препятствий нет, симулируем попадание в цель
    return {
        Instance = targetPart,
        Position = targetPart.Position,
        Normal = (targetPart.Position - origin).Unit,
        Material = Enum.Material.Plastic
    }
end

-- Подключение к Tool.Activated для Silent Aim
local function setupToolSilentAim(character)
    if not character then return end

    local function onToolEquipped(tool)
        if not tool:IsA("Tool") then return end
        showNotification("Tool equipped: " .. tool.Name, false)

        tool.Activated:Connect(function()
            local isActive = SilentAimSettings.Enabled or (SilentAimSettings.Mode == "Retention" and SilentAimSettings.IsKeyHeld)
            if not isActive then return end

            local closestPart = getClosestPlayer(SilentAimSettings)
            if not closestPart then
                showNotification("No target found for Silent Aim", true)
                return
            end

            -- Используем позицию персонажа вместо камеры
            local localRoot = character:FindFirstChild("HumanoidRootPart")
            if not localRoot then
                showNotification("LocalPlayer HumanoidRootPart not found", true)
                return
            end
            local origin = localRoot.Position
            local direction = (closestPart.Position - origin).Unit * 1000
            local raycastResult = simulateRaycast(origin, direction, closestPart)
            if raycastResult then
                showNotification("Silent Aim hit: " .. closestPart.Parent.Name, false)

                -- Находим RemoteEvent в инструменте
                local remote = tool:FindFirstChildWhichIsA("RemoteEvent")
                if remote then
                    -- Пробуем разные варианты вызова RemoteEvent
                    local hitData = {
                        Position = closestPart.Position,
                        Direction = (closestPart.Position - origin).Unit,
                        TargetPart = closestPart,
                        CFrame = CFrame.new(origin, closestPart.Position),
                        Timestamp = tick()
                    }

                    -- Вариант 1: Позиция и направление
                    remote:FireServer(closestPart.Position, (closestPart.Position - origin).Unit, closestPart)
                    showNotification("Fired RemoteEvent (Variant 1) for hit on " .. closestPart.Parent.Name, false)

                    -- Вариант 2: Только позиция
                    task.delay(0.1, function()
                        remote:FireServer(closestPart.Position)
                        showNotification("Fired RemoteEvent (Variant 2) for hit on " .. closestPart.Parent.Name, false)
                    end)

                    -- Вариант 3: CFrame и часть
                    task.delay(0.2, function()
                        remote:FireServer(CFrame.new(origin, closestPart.Position), closestPart)
                        showNotification("Fired RemoteEvent (Variant 3) for hit on " .. closestPart.Parent.Name, false)
                    end)
                else
                    showNotification("No RemoteEvent found in tool", true)
                end
            else
                showNotification("Silent Aim raycast failed", true)
            end
        end)
    end

    for _, child in pairs(character:GetChildren()) do
        if child:IsA("Tool") then
            onToolEquipped(child)
        end
    end

    character.ChildAdded:Connect(function(child)
        if child:IsA("Tool") then
            onToolEquipped(child)
        end
    end)
end

LocalPlayer.CharacterAdded:Connect(function(character)
    setupToolSilentAim(character)
end)

if LocalPlayer.Character then
    setupToolSilentAim(LocalPlayer.Character)
end

-- Инициализация UI
local SilentAimEnableCheckbox

local function initializeUI()
    if not CombatContent or initialized then return end
    initialized = true

    local SilentAimHeader = CombatContent:CollapsingHeader({Title = "Silent Aim"})
    SilentAimEnableCheckbox = SilentAimHeader:Checkbox({
        IniFlag = "SilentAim_Enabled",
        Label = "Silent Aim Enable",
        Value = SilentAimSettings.Enabled,
        Callback = function(self, value)
            SilentAimSettings.Enabled = value
            SilentAimSettings.IsKeyHeld = false
        end
    })

    SilentAimHeader:Combo({
        IniFlag = "SilentAim_Mode",
        Label = "Mode",
        Selected = SilentAimSettings.Mode,
        Items = {"Switch", "Retention"},
        Callback = function(self, value)
            SilentAimSettings.Mode = value
            SilentAimSettings.Enabled = false
            SilentAimSettings.IsKeyHeld = false
        end
    })

    SilentAimHeader:Checkbox({
        IniFlag = "SilentAim_UseFOV",
        Label = "Use FOV",
        Value = SilentAimSettings.UseFOV,
        Callback = function(self, value)
            SilentAimSettings.UseFOV = value
        end
    })

    SilentAimHeader:Checkbox({
        IniFlag = "SilentAim_VisFOV",
        Label = "Vis FOV",
        Value = SilentAimSettings.VisFOV,
        Callback = function(self, value)
            SilentAimSettings.VisFOV = value
        end
    })

    SilentAimHeader:SliderInt({
        IniFlag = "SilentAim_FOVRadius",
        Label = "FOV Size",
        Value = SilentAimSettings.FOVRadius,
        Minimum = 0,
        Maximum = 360,
        Callback = function(self, value)
            SilentAimSettings.FOVRadius = value
        end
    })

    SilentAimHeader:Checkbox({
        IniFlag = "SilentAim_ShowTarget",
        Label = "Show Target",
        Value = SilentAimSettings.ShowTarget,
        Callback = function(self, value)
            SilentAimSettings.ShowTarget = value
        end
    })

    SilentAimHeader:Checkbox({
        IniFlag = "SilentAim_WallCheck",
        Label = "Wall Check",
        Value = SilentAimSettings.WallCheck,
        Callback = function(self, value)
            SilentAimSettings.WallCheck = value
        end
    })

    SilentAimHeader:Checkbox({
        IniFlag = "SilentAim_TeamCheck",
        Label = "Team Check",
        Value = SilentAimSettings.TeamCheck,
        Callback = function(self, value)
            SilentAimSettings.TeamCheck = value
        end
    })

    SilentAimHeader:Keybind({
        IniFlag = "SilentAim_Bind",
        Label = "Bind",
        Value = SilentAimSettings.Bind,
        Callback = function(self, value)
            SilentAimSettings.Bind = value
        end
    })

    SilentAimHeader:Combo({
        IniFlag = "SilentAim_TargetPart",
        Label = "Target Part",
        Selected = SilentAimSettings.TargetPart,
        Items = {"Head", "HumanoidRootPart"},
        Callback = function(self, value)
            SilentAimSettings.TargetPart = value
        end
    })
end

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == SilentAimSettings.Bind then
        if SilentAimSettings.Mode == "Switch" then
            SilentAimSettings.Enabled = not SilentAimSettings.Enabled
            SilentAimSettings.IsKeyHeld = false
        elseif SilentAimSettings.Mode == "Retention" then
            SilentAimSettings.IsKeyHeld = true
            SilentAimSettings.Enabled = false
        end
    end
end)

UserInputService.InputEnded:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == SilentAimSettings.Bind and SilentAimSettings.Mode == "Retention" then
        SilentAimSettings.IsKeyHeld = false
    end
end)

local targetAlpha = 0
local silentColorTransition = 0
resume(create(function()
    RenderStepped:Connect(function()
        silent_fov_circle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
        silent_fov_circle.Radius = SilentAimSettings.FOVRadius
        silent_fov_circle.Visible = SilentAimSettings.VisFOV and (SilentAimSettings.Enabled or SilentAimSettings.IsKeyHeld)
        local ClosestSilent = getClosestPlayer(SilentAimSettings)
        if (SilentAimSettings.Enabled or SilentAimSettings.IsKeyHeld) and ClosestSilent then
            silentColorTransition = math.min(silentColorTransition + 0.05, 1)
        else
            silentColorTransition = math.max(silentColorTransition - 0.05, 0)
        end
        local sr = 255 - (silentColorTransition * 255)
        local sg = 255 - (silentColorTransition * 255)
        local sb = 255 - (silentColorTransition * 255)
        silent_fov_circle.Color = Color3.fromRGB(sr, sg, sb)

        if SilentAimSettings.ShowTarget and (SilentAimSettings.Enabled or SilentAimSettings.IsKeyHeld) then
            if ClosestSilent then
                local TargetPart = FindFirstChild(ClosestSilent.Parent, SilentAimSettings.TargetPart)
                if not TargetPart then TargetPart = FindFirstChild(ClosestSilent.Parent, "HumanoidRootPart") end
                local RootToViewportPoint, IsOnScreen = WorldToViewportPoint(Camera, TargetPart.Position)
                if IsOnScreen then
                    local Distance = (Camera.CFrame.Position - TargetPart.Position).Magnitude
                    local BaseSize = 10
                    local Size = math.max(BaseSize * (50 / math.max(Distance, 1)), 5)
                    target_box.Size = Vector2.new(Size, Size)
                    targetAlpha = 1
                    target_box.Visible = true
                    target_box.Position = Vector2.new(RootToViewportPoint.X, RootToViewportPoint.Y) - Vector2.new(Size / 2, Size / 2)
                else
                    targetAlpha = 0
                    target_box.Visible = false
                end
            else
                targetAlpha = 0
                target_box.Visible = false
            end
        else
            targetAlpha = 0
            target_box.Visible = false
        end
    end)
end))

-- Функция инициализации модуля
return function(content, services)
    CombatContent = content
    Players = services.Players or Players
    RunService = services.RunService or RunService
    Workspace = services.Workspace or Workspace
    LocalPlayer = services.LocalPlayer or LocalPlayer
    Camera = services.Camera or Camera
    GetPlayers = Players.GetPlayers
    WorldToScreen = Camera.WorldToScreenPoint
    WorldToViewportPoint = Camera.WorldToViewportPoint
    RenderStepped = RunService.RenderStepped
    initializeUI()
end
